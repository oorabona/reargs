# Reargs

RegExp based command line arguments parser.

[![NPM][npm-image]][npm-url]
[![Build Status][build-status-img]][build-status-link]
[![GitHub Project][github-image]][github-url]
[![API Documentation][api-docs-image]][API documentation]

[npm-image]: https://img.shields.io/npm/v/reargs.svg?logo=npm
[npm-url]: https://www.npmjs.com/package/reargs
[github-image]: https://img.shields.io/static/v1?logo=github&label=GitHub&message=project&color=informational
[github-url]: https://github.com/oorabona/reargs
[API documentation]: https://oorabona.github.io/reargs/

## So why another argument parser library ?

None of the ones I found are leveraging the power of RegExp ! :wink:
> With great power comes great responsability !

```sh
$ prog -m swagger dump api from https://api.endpoint.io -- do not parse
```

Or having multiple ways of asking for the same action:
```sh
$ prog -s
$ prog sh
$ prog shell
```

Last but not least, I wanted to have a descriptive help text out of the box. Thanks to [nunjucks](https://mozilla.github.io/nunjucks/) you just have to call [generateHelp](docs/) to have the magic :rainbow: !

## How does it work ?

Behind the scenes are Regular Expressions - hence the name - and the fact that they are both very flexible and more than enough for what we want.

### Instantiation

```js
// CommonJS
const Reargs = require('reargs')
const myArgs = new Reargs(params = {}, opts = null, debug = false)
```

```js
// ES2016
import Reargs from 'reargs'
const myArgs = new Reargs(params = {}, opts = null, debug = false)
```

#### Parameters

This object contains all the parameters, which in turn can have the following properties:

```js
const params = {
  help: {
    group: 'command',             // optional for command grouping, default is '_'
    short: '-h',                  // optional if `long` is set
    long: '--help',               // optional if `short` is set
    humanReadable: '-h, --help',  // optional (it is autogenerated if missing)
    help: 'this help',            // optional
    stopParse: true,              // default is **false**
    hidden: true,                 // default is **false**
  }
}
```

All commands can be grouped together using the `group` property. It can be useful to distinguish between `command`s and `option`s for example.

> Note: for consistency, if no group is provided, a default one '_' is set.

All arguments can have two forms, `short` and `long`.
Although they do not have to be shorter or longer one to the other, you can provide alternate versions if you need.

At least one of them is required, an exception is thrown otherwise.

> **Note**
These properties can be `string` or instances of `RegExp`. If you prefer using strings, please make sure you use double backslashs to escape.
E.g. the following are equivalent:

```js
const exampleWithStrings = {
  help: {
    help: 'this help or additional help on a given topic',
    short: '((?<topic>[\\w|\\/]+) )?-h',
    long: 'help( (?<topic>[\\w|\\/]+))?',
  }
}

const exampleWithRegExp = {
  help: {
    help: 'this help or additional help on a given topic',
    short: /((?<topic>[\w|\/]+) )?-h/,
    long: /help( (?<topic>[\w|\/]+))?/,
  }
}
```

A `humanReadable` text is computed from both `short` and `long` inputs (with the help of an option [longShortDelimiter](#longShortDelimiter)). If this does not suit the way you want it to appear when calling [generateHelp](#generateHelp), feel free to customize !

The `stopParse` parameter implies that everything after this parameter is discarded from the input.

See it as the usual `--` in your shell.

Lastly, the `hidden` flag will still parse the parameter but it will not be shown in the help generated with [generateHelp](#generateHelp). Of course you will have to implement the same logic if you want to customize your help output.

See [Help templates](#helpTemplates) below.

#### Options

A few options are also available to adjust `Reargs` behavior. Below are the default values:

```js
const opts = {
  longShortDelimiter: '\n',
  paramDescriptionSpacer: '.',
  prePaddingSpaces: 2,
  alignLongIfNoShort: 4,
  exitOnStop: false,
}
```

* `longShortDelimiter` will be used to generate the `humanReadable` documentation from `join`ing both `short` and `long` parameters variations.

* `paramDescriptionSpacer` is also used when calling [generateHelp](#generateHelp), and changes the spacing character used between parameters and the related help.

* `prePaddingSpaces` adds that many spaces (` `) at the beginning of each line describing a parameter.

* `alignLongIfNoShort` adds that many spaces before arguments that have no `short` property, to have a cleaner alignment with arguments having both `short` and `long` properties set.

* `exitOnStop` if set, stops immediately parsing when a parameter with `stopParse` property set to **true** is found, not evaluating anything else.

> **Note**
Although discouraged, `paramDescriptionSpacer` and `prePaddingSpaces` can be overriden ultimately in the template, because they are arguments of [padEnd](#padEnd) `Jinja2`-like modifier.

#### Debug

To help with debugging your configuration, a debug mechanism has been set up.

At several places in the code, some debug messages will be generated. Depending on the value of `debug` they will be outputted ... or not.

| debug value | meaning |
|-|-|
| false (default) | no debug output at all |
| true | debug will be output with `console.log` |
| ``` (...) => { do_whatever_you_want() }``` | a custom function taking as many arguments like `console.log` to suit your needs. |

### Parsing

Parsing is done as simply calling the following code :

```js
const unparsable = myArgs.parse(process.argv.slice(2))
```

Yep that's it ! It takes an `Array` as input argument, and returns the **unparsed** tokens.

> **Note**
The difference between `unparsed` and `remain` lies in that `remain` has never been given a chance to be parsed.
On the contrary, what is returned by the `parse` function has been given a chance to be parsed, unsuccesfully.

### Retrieving values

There are three different functions to retrieve the result after a call to [parse](#parse).

* **getValue** : get the value of a single argument (and if present the capture group)
* **getGroupValues** : get all the values from a specific group (see [groups](#groups))
* **getAllValues** : as the name suggests, retrieve all the values from all the parameters


```js
const value = myArgs.getValue(askforId, captureGroupName = null)
const groupValues = myArgs.getGroupValues(group)
const allValues = myArgs.getAllValues()
```

Let's go with an example. Consider this little snippet :

```js
// Definition
const myArgs = new Reargs({
  help: {
    help: 'this help or additional help on a given topic',
    short: '((?<topic>[\\w|\\/]+) )?-h',
    long: 'help( (?<topic>[\\w|\\/]+))?',
    humanReadable: 'help [topic], [topic] -h'
  }
})
const unparsable = myArgs.parse(process.argv.slice(2))
const valueOfParam = myArgs.getValue('help', 'topic')
```

The capturing group `topic` will store the value, if present.

If the program is called with only `help` as argument, the following will be true:

```js
const topic = myArgs.getValue('help', 'topic') // topic: undefined
const help = myArgs.getValue('help') // returns { topic: undefined }
const groupValues = myArgs.getGroupValues('_') // returns { topic: undefined }
const allValues = myArgs.getAllValues() // returns { topic: undefined }
```

> **Notes**
1. If an argument has a capturing group, its value is propagated
2. If no value could be found on the command line the default one, if it exists, will be propagated instead
3. You can have the same name between capturing group name and parameter name

#### Default values

Now let's consider the following example with default values :

```js
// Definition
const myArgs = new Reargs({
  help: {
    help: 'this help or additional help on a given topic',
    short: '((?<topic>[\\w|\\/]+) )?-h',
    long: 'help( (?<topic>[\\w|\\/]+))?',
    humanReadable: 'help [topic], [topic] -h',
    values: {
      topic: 'general'
    }
  }
})
const unparsable = myArgs.parse(process.argv.slice(2))
const valueOfParam = myArgs.getValue('help', 'topic')
```

If the program is called with only `help` as argument, the following will be true:

```js
const topic = myArgs.getValue('help', 'topic') // topic: 'general'
const help = myArgs.getValue('help') // returns { topic: 'general' }
const groupValues = myArgs.getGroupValues('_') // returns { topic: 'general' }
const allValues = myArgs.getAllValues() // returns { topic: 'general' }
```

### Generate Help

As you have seen, many options and properties are meant to ease the generation of help message.

Everything is handled by the [generateHelp](#generateHelp) with the following parameters:

| parameter name | default value | description | example
|-|-|-|-|
| contextHelp | {} | some properties can be overriden by default and you can add your own custom variables as well but you will have to use your own template | { name: "foobar", version: "1.0rc1" } |
| templateSource | defaultHelpTemplate | a [nunjucks](https://mozilla.github.io/nunjucks/) template | you can view the default below |

```js
// This will generate a help message with all parameters but default context values using the default template.
const helpMessage = myArgs.generateHelp()

// You can use your package.json to grab some useful values
const context = JSON.parse('package.json')
const customContext = myArgs.generateHelp(context)

// Or you can go further by providing your own template
const helpTemplate = `...`
const customHelp = myArgs.generateHelp(context, helpTemplate)
```

This is the default template :

```js
const defaultHelpTemplate = `
{{name}} v{{version}} - {{description}} - by {{author|safe}}

Usage:
  {{name}}{% for group,params in groups %} [{{ group }}]{% endfor %}

{% for group,params in groups %}
{{group|title}}s:
{% for param in params %}
{% if param.hidden != true -%}
{{ param.humanReadable|padEnd(params.padding, params.prepadding, opts.paramDescriptionSpacer)|safe }} {{param.help}}
{%- endif %}
{%- endfor %}
{% endfor -%}
`
```

It is pretty much self explanatory, please have a look a [nunjucks](https://mozilla.github.io/nunjucks/) for details.

## Contributing

Licence is [MIT](LICENSE), feel free to raise issues, provide PR or just drop a word about how you use it, what would be the next features you would like this piece of software to have.
